"VAR" <- function(x,p=1,output=T,include.mean=T,fixed=NULL){# Fits a vector AR(p) model, computes AIC, and residuals# fixed[i,j] = 1 denotes the parameter needs estimation, = 0, means fixed to 0.if(!is.matrix(x))x=as.matrix(x)if(p < 1)p=1T=dim(x)[1]k=dim(x)[2]idm=k*p+1ne=T-pist=p+1y=x[ist:T,]xmtx=NULLif(include.mean){xmtx=cbind(xmtx,rep(1,ne))}for (i in 1:p){xmtx=cbind(xmtx,x[(ist-i):(T-i),])}#ndim=ncol(xmtx)if(length(fixed)==0){paridx=matrix(1,ndim,k)}else {paridx=fixed}#perform estimation component-by-componentres=NULLbeta=matrix(0,ndim,k)sdbeta=matrix(0,ndim,k)for (i in 1:k){idx=c(1:ndim)[paridx[,i]==1]### consider the case in which y[,i] is a white noise with mean zero.resi=y[,i]if(length(idx) > 0){xm=xmtx[,idx]xpx=crossprod(xm,xm)xpxinv=solve(xpx)xpy=t(xm)%*%as.matrix(y[,i],ne,1)betai=xpxinv%*%xpybeta[idx,i]=betairesi=y[,i]-xm%*%betaisse=sum(resi*resi)/Tdd=diag(xpxinv)sdbeta[idx,i]=sqrt(dd*sse)}res=cbind(res,resi)}sse=crossprod(res,res)/T#aic=0bic=0Ph0=NULLPhi=NULLif(output){jst=0if(include.mean) {Ph0=beta[1,]sePh0=sdbeta[1,]cat("Constant term:","\n")cat("Estimates: ",Ph0,"\n")cat("Std.Error: ",sePh0,"\n")jst=1}cat("AR coefficient matrix","\n")## Phi is a storage to store AR coefficient matricesPhi=NULLfor (i in 1:p){cat("AR(",i,")-matrix","\n")phi=t(beta[(jst+1):(jst+k),])se=t(sdbeta[(jst+1):(jst+k),])print(phi,digits=3)cat("standard error","\n")print(se,digits=3)jst=jst+kPhi=cbind(Phi,phi)}cat(" ","\n")cat("Residuals cov-mtx:","\n")print(sse)cat(" ","\n")dd=det(sse)cat("det(SSE) = ",dd,"\n")d1=log(dd)aic=d1+(2*p*k*k)/Tbic=d1+log(T)*p*k*k/Tcat("AIC = ",aic,"\n")cat("BIC = ",bic,"\n")# end of if(output)}VAR<-list(data=x,cnst=include.mean,order=p,coef=beta,aic=aic,bic=bic,residuals=res,secoef=sdbeta,Sigma=sse,Phi=Phi,Ph0=Ph0)}